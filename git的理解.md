教程：

使用google，保持读取英文文档的习惯。

AIO:all in one   聊天（来自手Q） 

WNS:手Q登陆SDK，用这个SDK可以得到一个openId。

代码耦合：功能独立，不该依赖却依赖



编程习惯：

Xcode建立快捷键习惯

Beyond compare，一个代码比较工具，可以作为sourceTree的插件。

proxifer网络代理工具

OmniGraffer可以画代码接口图



效率：

减少编译时间，

先接口，再实现

先逻辑，再UI



MVVM/MVC：

model一般是数据定义（包括后台的裸数据）

viewModel会引用自己的view所需要的model（数据交互）



attach



关键词：

拉分支，更改，有的话拉取（没有的话用抓取check一下），提交，推送

如果提交后，发现有拉取，先把变更贮藏，再拉取，推送

贮藏，再拉取，应用贮藏，处理冲突，推送



工作区和暂存区：

Add,commit,push

文件从工作区add到暂存区，暂存区commit到本地分支，本地分支push到远端。

所以，`git add`命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行`git commit`就可以一次性把暂存区的所有修改提交到分支。

新建分支：选择某个分支节点（或检出某个分支，或回滚到某分支节点），新建分支，更改，提交，推送到远端。

拉取时有个选项：立即提交合并的改动，这个会将拉到的东西直接合并提交，也就是拉取+提交

抓取：抓取所有远端更新，用于查看有多少拉取。

贮藏和应用贮藏：在某个分支节点处，把一些更改存起来，把存货加进来。git stash



回滚的使用场景：推送的时候起冲突（冲突有时候需要协商解决），并且冲掉了代码，未拉取就提交。

回滚：选择待回滚的分支节点，右键选择reset develop to this commit，回滚节点都是本地的分支节点。

使用模式：

软合并：

混合合并：将工作区重置成该分支节点，但是保留工作副本（工作区）的改动。
如果是本地推送而没有远端推送，可以回滚到远端最新节点，混合合并，推送。
如果是本地推送而没有远端推送，并且远端有新的拉取，那么需要先回滚到本地分支节点，混合合并，再拉取远端，再推送，中间可能有冲突（涉及到merge），比如说自己的本地推送和远端起冲突，解决冲突后才能merge，并推送到远端。

强制合并：丢弃当前工作区的更改，相当于将工作区重置成该分支节点。注意推送是将当前本地分支节点推到远端对应的分支，由于已经重置，相当于空推送。

然后在版本号上选择提交回滚（把提交plus进来），推送。

整个过程就是，推送时冲突并冲掉了代码，回滚合并，提交回滚并推送。

（强行合并） 引用值，目录树和内容
–hard：git reset –hard 

替换master引用值为指定commit 

替换暂存区为指定commit中的目录树 

替换工作区为暂存区中的内容，也和指定commit的目录树内容相同  
（混合合并） 更改引用的指向以及重置暂存区
–mixed：git reset –mixed 或git reset （命令缺省选项为–mixed） 
更改引用的指向以及重置暂存区，但是不改变工作区。
（软合并） 更改引用
–soft：git reset –soft 
只更改引用的指向，不改变暂存区和工作区



文件修改但未提交（add）：可以使用重置

放弃区块：局部重置

重置：checkout，可以重置整个文件，批量重置

移除：意思是将该文件删除，就像你新增一个文件一样。移除时发现误删还是可以重置的。



Git同样告诉我们，用命令`git reset HEAD <file>`可以把暂存区的修改撤销掉（unstage），重新放回工作区：

`git reset`命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用`HEAD`时，表示最新的版本。

假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。

版本回退：回滚

场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD <file>`，就回到了场景1，第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)一节，不过前提是没有推送到远程库。





合并：假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。也就是直接把`master`指向`dev`的当前提交，就完成了合并。在sourceTree，切到master，拉取最新的master，切回dev，将master合到dev，这样的话本地的dev就是最新的了，还需要将dev推上去，最简单的就是将dev推到master分支。但是实际协作开发，需要审批和权限。

提交回滚：将commit回滚。重置是reset，提交回滚是revert

变基：

遴选：



注意：

1，不要强制变基，强制push等操作，也不要设置sourceTree的强制。

2，如果你在提交之前，有未拉取的代码，这个时候先拉取完之后再commit。否则经过上面的操作，会把别人提交的代码回退过去。



场景：工作区和暂存区（add）的错误可以直接重置，如果commit但没有push可以reset develop to this commit，然后选择合并方式，合并方式包括丢弃所有，保留更改。

软合并和混合合并的区别：

是否有记录，测试到混合会有两次提交记录，软的只有一次。



head:头指针。表示当前分支所处的位置。



合并或变基分别在什么情况下使用呢，个人总结的是，1-他人开发且提交历史比较长的分支，适合合并，这样可以保留整个提交历史，2-自己临时开发且提交历史时间线较短的分支，适合变基，这样在不在意这段提交历史时可以优化提交历史。



提交回滚：对该节点所做的变更全部撤销，并作为一次新的提交。

解决冲突的方式：自己的，他人的，手动

混合合并：保留工作副本的改动，且删除commit记录，能够减少节点记录。

软合并：会保留commit记录，可能会产生一次commit记录。

一般用混合合并。



合并：也就是两个节点的东西，合并成一个新的节点。

剩下的点：

解决冲突：找一个称手的冲突对比工具



下一步：xcode工具

