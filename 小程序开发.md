## 微信小程序：miniProgram

###### 网页开发和小程序开发的对比：

<img src="/Users/max/GithubRepositories/iOS-Develpoment/img/miniProgram/截屏2020-08-17 上午9.59.16.png" style="zoom: 50%;" />

###### 官方教程：

[开发指南](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=0008aeea9a8978ab0086a685851c0a)
[官方开发文档List](https://developers.weixin.qq.com/miniprogram/dev/framework/)
[开发工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)
[官方示例demo](https://github.com/wechat-miniprogram/miniprogram-demo)

###### 申请AppID：

打开 https://mp.weixin.qq.com/ 点击立即注册，注册成功之后，点击 “开发”—“开发设置” 就可以看到 AppID。
安装开发者工具，编写代码，点击“开发者工具”工具栏上的预览按钮，使用微信扫描生成的二维码，就可以看到小程序在手机端的表现了。

###### JSON 配置：

JSON 是一种数据格式，JSON文件在小程序代码中扮演静态配置的作用，在小程序运行之前就决定了小程序的一些表现。需要注意的是小程序是无法在运行时去动态更新JSON 配置文件从而发生对应的变化的。
JSON文件都是被包裹在一个大括号中 {}，通过key-value的方式来表达数据。JSON的值只能是以下几种数据格式：

1. 数字，包含浮点数和整数
2. 字符串，需要包裹在双引号中
3. Bool值，true 或者 false
4. 数组，需要包裹在方括号中 []
5. 对象，需要包裹在大括号中 {}
6. Null

还需要注意的是 JSON 文件中无法使用注释，试图添加注释将会引发报错。

###### WXML：

WXML 全称是 WeiXin Markup Language，是小程序框架设计的一套标签语言，结合小程序的基础组件、事件系统，可以构建出页面的结构。
WXML基本语法如下：

```html
<!-- 在此处写注释 -->
<标签名 属性名1="属性值1" 属性名2="属性值2" ...> ...</标签名>

<!-- 三元运算 -->
<text>{{ a === 10? "变量 a 等于10": "变量 a 不等于10"}}</text>

<!-- 算数运算：{ a: 1,  b: 2, c: 3 } -->
<view> {{a + b}} + {{c}} + d </view>
<!-- 输出 3 + 3 + d -->


<!-- { 字符串的拼接name: 'world' } -->
<view>{{"hello " + name}}</view>
<!-- 输出 hello world -->
<!-- {{ }}中还可以直接放置数字、字符串或者是数组 -->

<!-- 条件逻辑wx:if="{{condition}}" -->
<view wx:if="{{condition}}"> True </view>
<view wx:if="{{length > 5}}"> 1 </view>
<view wx:elif="{{length > 2}}"> 2 </view>
<view wx:else> 3 </view>


<!-- 
wx:if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用<block/>标签将多个组件包装起来，并在上边使用 wx:if 控制属性。
-->
<block wx:if="{{true}}">
  <view> view1 </view>
  <view> view2 </view>
</block>

<!-- 列表渲染wx:for -->
<!-- array 是一个数组 -->
<view wx:for="{{array}}">
  {{index}}: {{item.message}}
</view>

<!-- 对应的脚本文件
Page({
  data: {
    array: [{
      message: 'foo',
    }, {
      message: 'bar'
    }]
  }
})
-->

<!-- 
wx:for-item 指定数组当前元素的变量名
wx:for-index 指定数组当前下标的变量名
-->
<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
  {{idx}}: {{itemName.message}}
</view>

<!-- 
可将 wx:for 用在 <block/> 标签上，以渲染一个包含多节点的结构块。
-->
<block wx:for="{{[1, 2, 3]}}">
  <view> {{index}}: </view>
  <view> {{item}} </view>
</block>


<!-- 
使用 wx:key 示例（WXML）
-->
<switch wx:for="{{objectArray}}" wx:key="unique" > {{item.id}} </switch>
<button bindtap="switch"> Switch </button>
<button bindtap="addToFront"> Add to the front </button>


<switch wx:for="{{numberArray}}" wx:key="*this" > {{item}} </switch>
<button bindtap="addNumberToFront"> Add Number to the front </button>

<!-- 
使用 wx:key 示例（JavaScript）
-->
Page({
  data: {
    objectArray: [
      {id: 5, unique: 'unique_5'},
      {id: 4, unique: 'unique_4'},
      {id: 3, unique: 'unique_3'},
      {id: 2, unique: 'unique_2'},
      {id: 1, unique: 'unique_1'},
      {id: 0, unique: 'unique_0'},
    ],
    numberArray: [1, 2, 3, 4]
  },
  switch: function(e) {
    const length = this.data.objectArray.length
    for (let i = 0; i < length; ++i) {
      const x = Math.floor(Math.random() * length)
      const y = Math.floor(Math.random() * length)
      const temp = this.data.objectArray[x]
      this.data.objectArray[x] = this.data.objectArray[y]
      this.data.objectArray[y] = temp
    }
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addToFront: function(e) {
    const length = this.data.objectArray.length
    this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray)
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addNumberToFront: function(e){
    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    this.setData({
      numberArray: this.data.numberArray
    })
  }
})
```

注意：WXML中的属性是大小写敏感的。

###### WXML数据绑定

在 Web 开发中，开发者使用 JavaScript 通过Dom 接口来完成界面的实时更新。在小程序中，使用 WXML 语言所提供的数据绑定功能，来完成UI的实时更新。
WXML 通过 {{变量名}} 来绑定一个模块里 WXML 文件和对应的 JavaScript 文件中的 data 对象属性。

```html
//pages/wxml/index.wxml 
<!--pages/wxml/index.wxml-->
<text>当前时间：{{time}}</text>

//pages/wxml/index.js
Page({
  /**
   * 页面的初始数据
   */
  data: {
    time: (new Date()).toString()
  },
})
```

###### 模板

WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。

```html
<template name="msgItem">
  <view>
    <text> {{index}}: {{msg}} </text>
    <text> Time: {{time}} </text>
  </view>
</template>
```

使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入。

```html
<!--
item: {
  index: 0,
  msg: 'this is a template',
  time: '2016-06-18'
}
-->

<template name="msgItem">
  <view>
    <text> {{index}}: {{msg}} </text>
    <text> Time: {{time}} </text>
  </view>
</template>

<template is="msgItem" data="{{...item}}"/>
<!-- 输出
0: this is a template Time: 2016-06-18
-->
```

is可以动态决定具体需要渲染哪个模板：

```html
<template name="odd">
  <view> odd </view>
</template>

<template name="even">
  <view> even </view>
</template>

<block wx:for="{{[1, 2, 3, 4, 5]}}">
  <template is="{{item % 2 == 0 ? 'even' : 'odd'}}"/>
</block>

<!-- 输出
odd
even
odd
even
odd
-->
```

###### 引用

WXML 提供两种文件引用方式import和include。import 可使用目标文件定义的 template。

```html
<!-- item.wxml -->
<template name="item">
  <text>{{text}}</text>
</template>

<!-- index.wxml -->
<import src="item.wxml"/>

<template is="item" data="{{text: 'forbar'}}"/>
```

注意：import 有作用域的概念，也就是 import 不具有递归的特性，只会 import 目标文件中定义的 template，而不会 import 目标文件中 import 的 template。

**include** 可以将目标文件中除了 `<template/> <wxs/>` 外的整个代码引入，相当于是拷贝到 include 位置所示。

###### 共同属性

所有wxml 标签都支持的属性称之为共同属性：

| 属性名       | 类型         | 描述           | 注解                                     |
| ------------ | ------------ | -------------- | ---------------------------------------- |
| id           | String       | 组件的唯一标别 | 整个页面唯一                             |
| class        | String       | 组件的样式类   | 在对应的 WXSS 中定义的样式类             |
| style        | String       | 组件的内联样式 | 可以动态设置的内联样式                   |
| hidden       | Boolean      | 组件是否显示   | 所有组件默认显示                         |
| data-*       | Any          | 自定义属性     | 组件上触发的事件时，会发送给事件处理函数 |
| bind*/catch* | EventHandler | 组件的事件     |                                          |
|              |              |                |                                          |

#### WXSS 样式

WXSS（WeiXin Style Sheets）是一套用于小程序的样式语言，用于描述WXML的组件样式，也就是视觉上的效果。WXSS与Web开发中的CSS类似。项目公共样式：根目录中的app.wxss

项目公共样式，它会被注入到小程序的每个页面。页面样式：与app.json注册过的页面同名且位置同级的WXSS文件。其它样式：其它样式可以被项目公共样式和页面样式引用。

###### 选择器

| **类型**     | **选择器** | **样例**      | **样例描述**                                   |
| ------------ | ---------- | ------------- | ---------------------------------------------- |
| 类选择器     | .class     | .intro        | 选择所有拥有 class="intro" 的组件              |
| id选择器     | #id        | #firstname    | 选择拥有 id="firstname" 的组件                 |
| 元素选择器   | element    | view checkbox | 选择所有文档的 view 组件和所有的 checkbox 组件 |
| 伪元素选择器 | ::after    | view::after   | 在 view 组件后边插入内容                       |
| 伪元素选择器 | ::before   | view::before  | 在 view 组件前边插入内容                       |
|              |            |               |                                                |

###### 官方样式库：

WeUI是一套与微信原生视觉体验一致的基础样式库，包含button、cell、dialog、progress、toast、article、actionsheet、icon等各式原生。具体使用文档可参考：https://github.com/Tencent/weui-wxss

#### JavaScript 脚本

小程序的主要开发语言是 JavaScript ，开发者使用 JavaScript 来开发业务逻辑。
<img src="/Users/max/GithubRepositories/iOS-Develpoment/img/miniProgram/截屏2020-08-17 下午2.12.40.png" style="zoom: 33%;" />

小程序中的 JavaScript 是由ECMAScript 以及小程序框架和小程序 API 来实现的。同浏览器中的JavaScript 相比没有 BOM（浏览器对象模型）以及 DOM（文档对象模型），所以类似 JQuery、Zepto这种浏览器类库是无法在小程序中运行起来的，同样的缺少 Native 模块和NPM包管理的机制，小程序中无法加载原生库，也无法直接使用大部分的 NPM 包。不同的平台的小程序的脚本执行环境也是有所区别的。

###### 模块化

浏览器中，所有 JavaScript 是在运行在同一个作用域下的，定义的参数或者方法可以被后续加载的脚本访问或者改写。同浏览器不同，小程序中可以将任何一个JavaScript 文件作为一个模块，通过module.exports 或者 exports 对外暴露接口。

```javascript
// moduleA.js，暴露接口
module.exports = function( value ){
  return value * 2;
}

// B.js
// 在B.js中引用模块A
var multiplyBy2 = require('./moduleA')
var result = multiplyBy2(4)

//🌰2
var common = require('common.js')
Page({
  helloMINA: function() {
    common.sayHello('MINA')
  },
  goodbyeMINA: function() {
    common.sayGoodbye('MINA')
  }
})
```

###### 脚本的执行顺序

浏览器中，脚本严格按照加载的顺序执行。

```html
<html>
<head>
  <script src ="a.js"></script>
  <script src ="b.js"></script>
</head>
</html>
```

小程序中的脚本执行顺序有所不同。小程序的执行的入口文件是 app.js 。并且会根据其中 require 的模块顺序决定文件的运行顺序。

```javascript
/* app.js */
var a = require('./a.js')
var b = require('./b.js')
```

当 app.js 执行结束后，小程序会按照开发者在 app.json 中定义的 pages 的顺序，逐一执行。

```json
{
  "pages": [
    "pages/index/index",
    "pages/log/log",
    "pages/result/result"
  ],
  "window": {}
}
```

以上文件的执行顺序是：
app.js文件  pages/index/index.js 文件 page/log/log.js 文件 page/result/result.js 文件

###### 作用域

同浏览器中运行的脚本文件有所不同，小程序的脚本作用域同 NodeJS 更为相似。
在文件中声明的变量和函数只在该文件中有效，不同的文件可以声明同名的变量和函数。
当需要使用全局变量时，通过使用全局函数 getApp() 获取全局的实例，并设置相关属性值。

```javascript
// app.js 定义全局变量
App({
  globalValue: 'hello'
})
// a.js 设置全局变量的某个属性值
var global = getApp()
global.globalValue = 'globalValue'

// b.js访问全局变量
var global = getApp()
console.log(global.globalValue) 
```

注意：上述示例只有在 a.js 比 b.js 先执行才有效。

#### 宿主环境：

小程序可以调用宿主环境提供的微信客户端的能力，小程序会运行在不同版本的宿主环境下，因此也需要针对各个版本的宿主环境做程序兼容。

###### 渲染层和逻辑层

小程序的运行环境分成渲染层和逻辑层， WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。
WXML模板使用 view 标签，其子节点用 {{ }} 的语法绑定一个 msg 的变量，在 JS 脚本使用 this.setData 方法把 msg 字段设置成 “Hello World” ，

```javascript
<!-- WXML文件 -->
<view>{{ msg }}</view>

//js文件
Page({
  onLoad: function () {
    this.setData({ msg: 'Hello World' })
  }
})
```

这个例子我们可以看到：
1.渲染层和数据相关。
2.逻辑层负责产生、处理数据。
3.逻辑层通过 Page 实例的 setData 方法传递数据到渲染层。

###### 通信模型

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由Native（指微信客户端）转发，小程序的通信模型如图：
<img src="/Users/max/GithubRepositories/iOS-Develpoment/img/miniProgram/通信模型.png" style="zoom: 25%;" />

###### 数据驱动

通常界面视图和变量状态是相关联的。数据驱动是为了在状态变更时，视图也能自动变更。
WXML结构实际上等价于一棵Dom树，通过一个JS对象也可以来表达Dom树的结构。
<img src="/Users/max/GithubRepositories/iOS-Develpoment/img/miniProgram/数据驱动.png" style="zoom: 50%;" />

WXML可以先转成JS对象，然后再渲染出真正的Dom树。
<img src="/Users/max/GithubRepositories/iOS-Develpoment/img/miniProgram/数据驱动1.png" style="zoom:50%;" />

通过setData把msg数据从“Hello World”变成“Goodbye”，产生的JS对象对应的节点就会发生变化，此时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上，从而达到更新UI的目的，这就是“数据驱动”的原理。
<img src="/Users/max/GithubRepositories/iOS-Develpoment/img/miniProgram/数据驱动2.png" style="zoom:50%;" />

###### 双线程下的界面渲染

小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。
<img src="/Users/max/GithubRepositories/iOS-Develpoment/img/miniProgram/界面渲染.png" style="zoom:50%;" />

###### 程序构造器App()

宿主环境提供了 App() 构造器用来注册一个程序App，需要留意的是App() 构造器必须写在项目根目录的app.js里，App实例是单例对象，在其他JS脚本中可以使用宿主环境提供的 getApp() 来获取程序实例。

```javascript
// app.js  APP构造器
App({
  onLaunch: function(options) {},
  onShow: function(options) {},
  onHide: function() {},
  onError: function(msg) {},
  globalData: 'I am global data'
})

// other.js
var appInstance = getApp()
```

App构造器接受一个Object参数，其中onLaunch / onShow / onHide 三个回调是App实例的生命周期函数。具体的参数说明如下：

| 参数属性 | 类型     | 描述                                                         |
| -------- | -------- | ------------------------------------------------------------ |
| onLaunch | Function | 当小程序初始化完成时，会触发 onLaunch（全局只触发一次        |
| onShow   | Function | 当小程序启动，或从后台进入前台显示，会触发 onShow            |
| onHide   | Function | 当小程序从前台进入后台，会触发 onHide                        |
| onError  | Function | 当小程序发生脚本错误，或 API 调用失败时，会触发 onError 并带上错误信息 |
| 其他字段 | 任意     | 可以添加任意的函数或数据到 Object 参数中，在App实例回调用 this 可以访问 |
|          |          |                                                              |

###### 生命周期和打开场景

**onLaunch**：初次进入小程序的时候，微信客户端初始化好宿主环境，同时从网络下载或者从本地缓存中拿到小程序的代码包，把它注入到宿主环境，初始化完毕后，微信客户端就会给App实例派发onLaunch事件，App构造器参数所定义的onLaunch方法会被调用。
**onHide**：进入小程序之后，用户可以点击右上角的关闭，或者按手机设备的Home键离开小程序，此时小程序并没有被直接销毁，我们把这种情况称为“小程序进入后台状态”，App构造器参数所定义的onHide方法会被调用。
**onShow**：当再次回到微信或者再次打开小程序时，微信客户端会把“后台”的小程序唤醒，我们把这种情况称为“小程序进入前台状态”，App构造器参数所定义的onShow方法会被调用。

我们可以看到，App的生命周期是由微信客户端根据用户操作主动触发的。为了避免程序上的混乱，我们不应该从其他代码里主动调用App实例的生命周期函数。

在微信客户端中打开小程序有很多途径：从群聊会话里打开，从小程序列表中打开，通过微信扫一扫二维码打开，从另外一个小程序打开当前小程序等，针对不同途径的打开方式，小程序有时需要做不同的业务处理，所以微信客户端会把打开方式给到onLaunch和onShow的参数options。要获取最新的场景值说明请查看官方文档：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html。

```javascript
App({
  onLaunch: function(options) { console.log(options) },
  onShow: function(options) { console.log(options) }
})
```

| 字段               | 类型   | 描述                                                    |
| ------------------ | ------ | ------------------------------------------------------- |
| path               | String | 打开小程序的页面路径                                    |
| query              | Object | 打开小程序的页面参数query                               |
| scene              | Number | 打开小程序的场景值，详细场景值请参考小程序官方文档      |
| shareTicket        | String | shareTicket，详见小程序官方文档                         |
| referrerInfo       | Object | 当场景为由从另一个小程序或公众号或App打开时，返回此字段 |
| referrerInfo.appId | String | 来源小程序或公众号或App的 appId，详见官方文档           |
|                    |        |                                                         |

###### 小程序全局数据

小程序的JS脚本是运行在JsCore的线程里，每个页面各自有一个WebView线程进行渲染，所以小程序切换页面时，小程序逻辑层的JS脚本运行上下文依旧在同一个JsCore线程中。
App实例是单例的，因此不同页面可以通过App实例下的属性来共享数据。

```javascript
// app.js
App({
  globalData: 'I am global data' // 全局共享数据
})
// 其他页面脚本other.js
var appInstance = getApp()
console.log(appInstance.globalData) // 输出: I am global data
```

注意：所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理。

###### 页面

一个页面是分三部分组成：界面、配置和逻辑。界面由WXML文件和WXSS文件来负责描述，配置由JSON文件进行描述，页面逻辑则是由JS脚本文件负责。

一个页面的文件需要放置在同一个目录下，其中WXML文件和JS文件是必须存在的，JSON和WXSS文件是可选的。
页面路径需要在小程序代码根目录app.json中的pages字段声明，否则这个页面不会被注册到宿主环境中。

```json
{
  "pages":[
    "pages/index/page", // 第一项默认为首页
    "pages/other/other"
  ]
}
```

###### 页面构造器Page()

宿主环境提供了 Page() 构造器用来注册一个小程序页面，Page()在页面脚本page.js中调用，Page构造器接受一个Object参数，其中data属性是当前页面WXML模板中可以用来做数据绑定的初始数据。另外onLoad / onReady / onShow / onHide /onUnload 5个回调是Page实例的生命周期函数；onPullDownRefresh / onReachBottom / onShareAppMessage / onPageScroll 4个回调是页面的用户行为。

```javascript
Page({
  data: { text: "This is page data." },
  onLoad: function(options) { },
  onReady: function() { },
  onShow: function() { },
  onHide: function() { },
  onUnload: function() { },
  onPullDownRefresh: function() { },
  onReachBottom: function() { },
  onShareAppMessage: function () { },
  onPageScroll: function() { }
})
```

| 参数属性          | 类型     | 描述                                                    |
| ----------------- | -------- | ------------------------------------------------------- |
| data              | Object   | 页面的初始数据                                          |
| onLoad            | Function | 生命周期函数--监听页面加载，触发时机早于onShow和onReady |
| onReady           | Function | 生命周期函数--监听页面初次渲染完成                      |
| onShow            | Function | 生命周期函数--监听页面显示，触发事件早于onReady         |
| onHide            | Function | 生命周期函数--监听页面隐藏                              |
| onUnload          | Function | 生命周期函数--监听页面卸载                              |
| onPullDownRefresh | Function | 页面相关事件处理函数--监听用户下拉动作                  |
| onReachBottom     | Function | 页面上拉触底事件的处理函数                              |
| onShareAppMessage | Function | 用户点击右上角转发                                      |
| onPageScroll      | Function | 页面滚动触发事件的处理函数                              |
|                   |          |                                                         |

###### 页面的生命周期和打开参数

页面初次加载的时候，微信客户端就会给Page实例派发onLoad事件，Page构造器参数所定义的onLoad方法会被调用，onLoad在页面没被销毁之前只会触发1次，在onLoad的回调中，可以获取当前页面所调用的打开参数option。
页面显示之后，Page构造器参数所定义的onShow方法会被调用，一般从别的页面返回到当前页面时，当前页的onShow方法都会被调用。
在页面初次渲染完成时，Page构造器参数所定义的onReady方法会被调用，onReady在页面没被销毁前只会触发1次，onReady触发时，表示页面已经准备妥当，在逻辑层就可以和视图层进行交互了。
以上三个事件触发的时机是onLoad早于 onShow，onShow早于onReady。
页面不可见时，Page构造器参数所定义的onHide方法会被调用，这种情况会在使用wx.navigateTo切换到其他页面、底部tab切换时触发。
当前页面使用wx.redirectTo或wx.navigateBack返回到其他页时，当前页面会被微信客户端销毁回收，此时Page构造器参数所定义的onUnload方法会被调用。
我们可以看到，Page的生命周期是由微信客户端根据用户操作主动触发的。为了避免程序上的混乱，我们不应该在其他代码中主动调用Page实例的生命周期函数。
最后我们说一下页面的打开参数query，让我们来设想这样一个场景，我们实现一个购物商城的小程序，我们需要完成一个商品列表页和商品详情页，点击商品列表页的商品就可以跳转到该商品的详情页，当然我们不可能为每个商品单独去实现它的详情页。我们只需要实现一个商品详情页的pages/detail/detail.*(代表WXML/WXSS/JS/JSON文件)*即可，在列表页打开商品详情页时把商品的id传递过来，详情页通过刚刚说的onLoad回调的参数option就可以拿到商品id，从而绘制出对应的商品。

```javascript
// pages/list/list.js
// 列表页使用navigateTo跳转到详情页
wx.navigateTo({ url: 'pages/detail/detail?id=1&other=abc' })

// pages/detail/detail.js
Page({
  onLoad: function(option) {
        console.log(option.id)
        console.log(option.other)
  }
})
```

小程序把页面的打开路径定义成页面URL，其组成格式和网页的URL类似，在页面路径后使用英文 ? 分隔path和query部分，query部分的多个参数使用 & 进行分隔，参数的名字和值使用 key=value 的形式声明。在页面Page构造器里onLoad的option可以拿到当前页面的打开参数，其类型是一个Object，其键值对与页面URL上query键值对一一对应。和网页URL一样，页面URL上的value如果涉及特殊字符（例如：&字符、?字符、中文字符等，详情参考URI的RFC3986说明 ），需要采用UrlEncode后再拼接到页面URL上。

###### 页面的数据

小程序的页面结构由WXML进行描述，页面数据就是页面Page构造器的data字段，data参数是页面第一次渲染时从逻辑层传递到渲染层的数据。

```javascript
<!-- page.wxml -->
<view>{{text}}</view>
<view>{{array[0].msg}}</view>

// page.js
Page({
  data: {
    text: 'init data',
    array: [{msg: '1'}, {msg: '2'}]
  }
})
```

Page构造器的data字段只是初始化数据。我们可以在Page实例下调用this.setData把数据传递给渲染层，从而达到更新界面的目的。由于小程序的渲染层和逻辑层分别在两个线程中运行，所以setData传递数据实际是一个异步的过程，所以setData的第二个参数是一个callback回调，在界面渲染完毕后触发。
setData其一般调用格式是 setData(data, callback)，其中data是由多个key: value构成的Object对象。

```javascript
// page.js
Page({
  onLoad: function(){
    this.setData({
      text: 'change data'
    }, function(){
      // 在这次setData对界面渲染完毕后触发
    })
  }
})
```

实际开发时，页面的data会涉及相当多的字段，你并不需要每次都将整个data字段重设一遍，你只需要设置改变的值即可。

注意：

1. 由于setData是需要两个线程的一些通信消耗，为了提高性能，每次设置的数据不应超过1024kB。
2. 不要把data中的任意一项的value设为undefined，否则可能会有引起一些不可预料的bug。

###### 页面的用户行为

小程序宿主环境提供了四个和页面相关的用户行为回调：

1. 下拉刷新 onPullDownRefresh
   监听用户下拉刷新事件，需要在app.json的window选项中或页面配置page.json中设置enablePullDownRefresh为true。当处理完数据刷新后，wx.stopPullDownRefresh可以停止当前页面的下拉刷新。
2. 上拉触底 onReachBottom
   监听用户上拉触底事件。可以在app.json的window选项中或页面配置page.json中设置触发距离onReachBottomDistance。在触发距离内滑动期间，本事件只会被触发一次。
3. 页面滚动 onPageScroll
   监听用户滑动页面事件，参数为 Object，包含 scrollTop 字段，表示页面在垂直方向已滚动的距离（单位px）。
4. 用户转发 onShareAppMessage
   只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮，在用户点击转发按钮的时候会调用，此事件需要return一个Object，包含title和path两个字段，用于自定义转发内容，如代码清单3-13所示。

```javascript
// page.js
Page({
onShareAppMessage: function () {
 return {
   title: '自定义转发标题',
   path: '/page/user?id=123'
 }
}
})
```

###### 页面跳转和路由

可以通过wx.navigateTo推入一个新的页面，在首页使用2次wx.navigateTo后，页面层级会有三层，我们把这样的一个页面层级称为页面栈。

假设当前页面栈为：[ pageA, pageB, pageC ]，使用 wx.navigateTo({ url: 'pageD' }) 可以推入一个 pageD，此时页面栈变成 [ pageA, pageB, pageC, pageD ]。
使用 wx.navigateBack() 可以退出顶部页面，此时页面栈变成 [ pageA, pageB, pageC ]。
使用wx.redirectTo({ url: 'pageE' }) 是替换当前页变成pageE，此时页面栈变成 [ pageA, pageB, pageE ]，当页面栈到达10层没法再新增的时候，往往就是使用redirectTo这个API进行页面跳转。
小程序提供了原生的Tabbar支持，我们可以在app.json声明tabBar字段来定义Tabbar页面。Tabbar页面也就是小程序底部的tab图标加文字（注：更多详细参数见Tabbar官方文档 ）。

```json
{
  "tabBar": {
    "list": [
      { "text": "Tab1", "pagePath": "pageA" },
      { "text": "Tab1", "pagePath": "pageF" },
      { "text": "Tab1", "pagePath": "pageG" }
    ]
  }
}
```

我们可以在刚刚的例子所在的页面栈中使用wx.switchTab({ url: 'pageF' })，此时原来的页面栈会被清空（除了已经声明为Tabbar页pageA外其他页面会被销毁），然后会切到pageF所在的tab页面，页面栈变成 [ pageF ]，此时点击Tab1切回到pageA时，pageA不会再触发onLoad，因为pageA没有被销毁。
注意⚠️，wx.navigateTo和wx.redirectTo只能打开非TabBar页面，wx.switchTab只能打开Tabbar页面。
我们还可以使用 wx. reLaunch({ url: 'pageH' }) 重启小程序，并且打开pageH，此时页面栈为 [ pageH ]。

#### 组件

一个小程序页面可以分解成多个部分组成，组件就是小程序页面的基本组成单元。
小程序使用标签名来引用一个组件，通常包含开始标签和结束标签，标签属性用来描述该组件。
注意⚠️，所有组件名和属性都是小写，多个单词会以英文横杠 "-" 进行连接。

```html
<!-- page.wxml -->
<view>
  <image mode="scaleToFill" src="img.png"></image>
  <view>
    <view>1</view>
    <view>2</view>
    <view>3</view>
  </view>
</view>
```

####  API

宿主环境提供了丰富的API，可以很方便调起native提供的能力。小程序提供的API按照功能主要分为几大类：网络、媒体、文件、数据缓存、位置、设备、界面、界面节点信息还有一些特殊的开放接口，我们介绍一下API一般调用的约定：

1. wx.on* 开头的 API 是监听某个事件发生的API接口，接受一个 Callback 函数作为参数。当该事件触发时，会调用 Callback 函数。
2. 如未特殊约定，多数 API 接口为异步接口 ，都接受一个Object作为参数。
3. API的Object参数一般由success、fail、complete三个回调来接收接口调用结果，示例代码如代码清单3-17所示，详细说明如表3-9所示。
4. wx.get* 开头的API是获取宿主环境数据的接口。
5. wx.set* 开头的API是写入数据到宿主环境的接口。

```javascript
wx.request({
url: 'test.php',
data: {},
header: { 'content-type': 'application/json' },
success: function(res) {
 // 收到https服务成功后返回
 console.log(res.data)
},
fail: function() {
 // 发生网络错误等情况触发
},
complete: function() {
 // 成功或者失败后触发
}
})
```

注意⚠️，API调用大多都是异步的。

#### 事件

用户点击界面等行为应该通知逻辑层。视频播放时播放进度一直变化，这种反馈也应该通知给逻辑层。在小程序里，把这种“用户在渲染层的行为反馈”以及“组件的部分状态反馈”抽象为渲染层传递给逻辑层的“事件”。

```html
<!-- page.wxml -->
<view id="tapTest" data-hi="WeChat" bindtap="tapName"> Click me! </view>

// page.js
   Page({
  tapName: function(event) {
    console.log(event)
  }
})
```

事件是通过bindtap这个属性绑定在组件上的，同时在当前页面的Page构造器中定义对应的事件处理函数tapName，当用户点击该view区域时，达到触发条件生成事件tap，该事件处理函数tapName会被执行，同时还会收到一个事件对象event。

###### 事件类型和事件对象

常见的事件类型：

| 类型           | 触发条件                                                     |
| -------------- | ------------------------------------------------------------ |
| touchstart     | 手指触摸动作开始                                             |
| touchmove      | 手指触摸后移动                                               |
| touchcancel    | 手指触摸动作被打断，如来电提醒，弹窗                         |
| touchend       | 手指触摸动作结束                                             |
| tap            | 手指触摸后马上离开                                           |
| longpress      | 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 |
| animationstart | 会在一个 WXSS animation 动画开始时触发                       |
| animationend   | 会在一个 WXSS animation 动画完成时触发                       |
|                |                                                              |

当事件回调触发的时候，会收到一个事件对象，对象的详细属性如下：

| 属性      | 类型    | 说明                             |
| --------- | ------- | -------------------------------- |
| type      | String  | 事件类型                         |
| timeStamp | Integer | 页面打开到触发事件所经过的毫秒数 |
| target    | Object  | 触发事件的组件的一些属性值集合   |
|           |         |                                  |

```html
<!-- page.wxml -->
<view id="outer" catchtap="handleTap">
  <view id="inner">点击我</view>
</view>

// page.js
Page({
  handleTap: function(evt) {
       // 当点击inner节点时
    // evt.target 是inner view组件
       // evt.currentTarget 是绑定了handleTap的outer view组件
       // evt.type == “tap”
       // evt.timeStamp == 1542
       // evt.detail == {x: 270, y: 63}
       // evt.touches == [{identifier: 0, pageX: 270, pageY: 63, clientX: 270, clientY: 63}]
       // evt.changedTouches == [{identifier: 0, pageX: 270, pageY: 63, clientX: 270, clientY: 63}]
  }
})
```

#### 兼容

可以使用 wx.getSystemInfo 或者 wx.getSystemInfoSync 来获取手机品牌、操作系统版本号、微信版本号以及小程序基础库版本号等。

```javascript
wx.getSystemInfoSync()
/*
  {
    brand: "iPhone",      // 手机品牌
    model: "iPhone 6",    // 手机型号
    platform: "ios",      // 客户端平台
    system: "iOS 9.3.4",  // 操作系统版本
    version: "6.5.23",    // 微信版本号
    SDKVersion: "1.7.0",  // 小程序基础库版本
    language: "zh_CN",    // 微信设置的语言
    pixelRatio: 2,        // 设备像素比
    screenWidth: 667,    // 屏幕宽度
    screenHeight: 375,     // 屏幕高度
    windowWidth: 667,    // 可使用窗口宽度
    windowHeight: 375,     // 可使用窗口高度
    fontSizeSetting: 16   // 用户字体大小设置
  }
 */

if (wx.openBluetoothAdapter) {
  wx.openBluetoothAdapter()
} else {
  // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示
  wx.showModal({
    title: '提示',
    content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'
  })
}
```

#### 开发流程：

主要任务：完成WXML+WXSS还原设计稿。按照页面交互梳理出每个页面的data部分，填充WXML的模板语法，还有完成JS逻辑部分。

###### Flex布局

如果小程序要求兼容到iOS8以下版本，需要开启样式自动补全。在“设置”—“项目设置”—勾选“上传代码时样式自动补全”。

默认的情况下，水平方向的是主轴（main axis），垂直方向的是交叉轴（cross axis）。项目是在主轴上排列，排满后在交叉轴方向换行。

**flex-direction 属性**

```css
.container{
  flex-direction: row（默认值） | row-reverse | column | column-reverse
}
```

row（默认值）：主轴横向，方向为从左指向右。项目沿主轴排列，从左到右排列。
row-reverse：row的反方向。主轴横向，方向为从右指向左。
column：主轴纵向，方向从上指向下。
column-reverse：column的反方向。主轴纵向，方向从下指向上。

**flex-wrap 属性**
设置是否允许项目多行排列，以及多行排列时换行的方向。

```css
.container{
  flex-wrap: nowrap（默认值） | wrap | wrap-reverse
}
```

nowrap（默认值）：不换行。如果单行内容过多，则溢出容器。
wrap：容器单行容不下所有项目时，换行排列。
wrap-reverse：容器单行容不下所有项目时，换行排列。换行方向为wrap时的反方向。

更多介绍详见官方文档。

###### 触摸反馈

小程序的view容器组件和button组件提供了hover-class属性，触摸时会往该组件加上对应的class改变组件的样式，如按键置灰。

```html
/*page.wxss */
.hover{
  background-color: gray;
}

<!--page.wxml -->
<button hover-class="hover"> 点击button </button>
<view hover-class="hover"> 点击view</view>
```

对于耗时操作，可以使用loading属性。

```html
<!--page.wxml -->
<button loading="{{loading}}" bindtap="tap">操作</button>


//page.js
Page({
  data: { loading: false },
  tap: function() {
  // 把按钮的loading状态显示出来
    this.setData({
      loading: true
    })
    // 接着做耗时的操作
  }
})
```

**Toast**
Toast提示默认1.5秒后自动消失，其表现形式如图4-19所示。

```json
Page({
  onLoad: function() {
    wx.showToast({ // 显示Toast
      title: '已发送',
      icon: 'success',
      duration: 1500
    })
    // wx.hideToast() // 隐藏Toast
  }
})
```

**模态对话框**：对于错误提示，因为要明确告知用户具体原因，所以不适合用一闪而过的Toast弹出式提示。一般使用模态对话框来提示。

```javascript
Page({
  onLoad: function() {
    wx.showModal({
      title: '标题',
      content: '告知当前状态，信息和解决方法',
      confirmText: '主操作',
      cancelText: '次要操作',
      success: function(res) {
        if (res.confirm) {
          console.log('用户点击主操作')
    		} else if (res.cancel) {
          console.log('用户点击次要操作')
        }
      }
    })
  }
})
```

###### 界面滚动

```javascript
//页面下拉刷新
//page.json
{"enablePullDownRefresh": true }

//page.js
Page({
  onPullDownRefresh: function() {
    // 用户触发了下拉刷新操作
    // 拉取新数据重新渲染界面
    // wx.stopPullDownRefresh() // 可以停止当前页面的下拉刷新。
  }
})



//上拉触底
//page.json
// 界面的下方距离页面底部距离小于onReachBottomDistance像素时触发onReachBottom回调
{"onReachBottomDistance": 100 }

//page.js
Page({
  onReachBottom: function() {
    // 当界面的下方距离页面底部距离小于100像素时触发回调
  }
})
```

当然有时不想整个页面进行滚动，而是页面中某一小块区域可滚动，此时就要用到scroll-view可滚动视图组件。组件的scroll-x和scroll-y属性决定滚动区域横向或者纵向滚动，scroll-view组件也提供了丰富的滚动回调触发事件，具体细节可参考官方文档scroll-view组件。

#### HTTPS网络通信

```javascript
wx.request({
  url: 'https://test.com/getinfo',
  success: function(res) {
    console.log(res)// 服务器回包信息
  }
```

wx.request详细参数：

| **参数名** | **类型**      | **必填** | **默认值** | **描述**                                                     |
| ---------- | ------------- | -------- | ---------- | ------------------------------------------------------------ |
| url        | String        | 是       |            | 开发者服务器接口地址                                         |
| data       | Object/String | 否       |            | 请求的参数                                                   |
| header     | Object        | 否       |            | 设置请求的 header，header 中不能设置 Referer，默认header['content-type'] = 'application/json' |
| method     | String        | 否       | GET        | （需大写）有效值：OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT |
| dataType   | String        | 否       | json       | 回包的内容格式，如果设为json，会尝试对返回的数据做一次 JSON解析 |
| success    | Function      | 否       |            | 收到开发者服务成功返回的回调函数，其参数是一个Object         |
| fail       | Function      | 否       |            | 接口调用失败的回调函数                                       |
| complete   | Function      | 否       |            | 接口调用结束的回调函数（调用成功、失败都会执行）             |
|            |               |          |            |                                                              |

```javascript
 // 通过data参数传递数据
wx.request({
  url: 'https://test.com/getinfo',
  data: { id:1, version:'1.0.0' },
  success: function(res) {
    console.log(res)// 服务器回包信息
  }
})
```

再来看看POST请求的情况，并不是所有请求都是按照键值对key=value的形式传递到后台，有时候需要传一些比较复杂的数据结构到后台，用JSON格式会更加合适。此时可以在wx.request的header参数设置content-type头部为application/json，小程序发起的请求的包体内容就是data参数对应的JSON字符串。

```javascript
// 请求的包体为 {"a":{"b":[1,2,3],"c":{"d":"test"}}}
wx.request({
  url: 'https://test.com/postdata',
  method: 'POST',
  header: { 'content-type': 'application/json'},
  data: {
    a: {
        b: [1, 2, 3],
        c: { d: "test" }
       }
   },
   success: function(res) {
    console.log(res)// 服务器回包信息
  }
})
```

通过wx.request发送请求后，服务器处理请求并返回HTTP包，小程序端收到回包后会触发success回调，同时回调会带上一个Object信息。

| **参数名** | **类型**      | **描述**                                |
| :--------- | :------------ | :-------------------------------------- |
| data       | Object/String | 开发者服务器返回的数据                  |
| statusCode | Number        | 开发者服务器返回的 HTTP 状态码          |
| header     | Object        | 开发者服务器返回的 HTTP Response Header |

success回调的参数data字段类型是根据header['content-type']决定的，默认header['content-type']是'application/json'，在触发success回调前，小程序宿主环境会对data字段的值做JSON解析，如果解析成功，那么data字段的值会被设置成解析后的Object对象，其他情况data字段都是String类型，其值为HTTP回包包体。

一个🌰：

```javascript
var hasClick = false;
Page({
  tap: function() {
    if (hasClick) {
      return
    }
    hasClick = true
    wx.showLoading()

    wx.request({
      url: 'https://test.com/getinfo',
      method: 'POST',
      header: { 'content-type':'application/json' },
      data: { },
      success: function (res) {
        if (res.statusCode === 200) {
          console.log(res.data)// 服务器回包内容
        }
      },
      fail: function (res) {
        wx.showToast({ title: '系统错误' })
      },
      complete: function (res) {
        wx.hideLoading()
        hasClick = false
      }
    })
  }
})
```

为了防止用户快速触发两次tap回调，我们还加了一个hasClick的“锁”，在开始请求前检查是否已经发起过请求，如果没有才发起这次请求，等到请求返回之后再把锁的状态恢复回去。

#### 微信登录态

![](/Users/max/GithubRepositories/iOS-Develpoment/img/miniProgram/微信登录态.png)

######  获取微信登录凭证code

为了业务安全，wx.login是生成一个带有时效性的凭证，就像一个会过期的临时身份证一样。调用wx.login后，先在微信后台生成一张临时的身份证，其有效时间仅为5分钟[[1\]](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000cc48f96c5989b0086ddc7e56c0a#_ftn6)。然后把这个临时身份证返回给小程序方，这个临时的身份证称为微信登录凭证code。如果5分钟内小程序的后台不拿着这个临时身份证来微信后台服务器换取微信用户id的话，那么这个身份证就会被作废。

###### 发送登录凭证code到小程序开发者服务器

小程序在wx.login的success回调中拿到微信登录凭证，紧接着会通过wx.request把code传到开发者服务器，为了后续可以换取微信用户身份id。如果当前微信用户还没有绑定当前小程序业务的用户身份，那在这次请求应该顺便把用户输入的帐号密码[[2\]](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000cc48f96c5989b0086ddc7e56c0a#_ftn7)一起传到后台，然后开发者服务器就可以校验账号密码之后再和微信用户id进行绑定，小程序端的示例代码如下：

```javascript
Page({
  tapLogin: function() {
    wx.login({
      success: function(res) {
        if (res.code) {
          wx.request({
            url: 'https://test.com/login',
            data: {
              username: 'zhangsan', // 用户输入的账号
              password: 'pwd123456', // 用户输入的密码
              code: res.code
            },

            success: function(res) {
              // 登录成功
              if (res.statusCode === 200) {
               console.log(res.data.sessionId)// 服务器回包内容
              }
            }
          })
        } else {
          console.log('获取用户登录态失败！' + res.errMsg)
        }
      }
    });
  }
})
```

###### 开发者服务器到微信服务器换取微信用户身份id

开发者的后台就拿到了前边wx.login()所生成的微信登录凭证code，凭借code到微信服务器换取微信用户身份。微信服务器为了确保拿code过来换取身份信息的人就是刚刚对应的小程序开发者，到微信服务器的请求要同时带上AppId和AppSecret，这两个信息在小程序管理平台的开发设置界面[[3\]](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000cc48f96c5989b0086ddc7e56c0a#_ftn8)可以看到，由此可以看出，AppId和AppSecret是微信鉴别开发者身份的重要信息，AppId是公开信息，泄露AppId不会带来安全风险，但是AppSecret是开发者的隐私数据不应该泄露，code在成功换取一次信息之后也会立即失效，即便凭证code生成时间还没过期。

开发者服务器和微信服务器通信也是通过HTTPS协议，微信服务器提供的接口地址是：https://api.weixin.qq.com/sns/jscode2session?appid=%3CAppId%3E&secret=%3CAppSecret%3E&js_code=%3Ccode%3E&grant_type=authorization_code
URL的query部分的参数中 <AppId>, <AppSecret>, <code> 就是前文所提到的三个信息，请求参数合法的话，接口会返回以下字段。

| **字段**    | **描述**                                                     |
| :---------- | :----------------------------------------------------------- |
| openid      | 微信用户的唯一标识                                           |
| session_key | 会话密钥                                                     |
| unionid     | 用户在微信开放平台的唯一标识符。本字段在满足一定条件的情况下才返回。 |

我们暂时只要关注前两个字段即可，openid就是前文一直提到的微信用户id。session_key则是微信服务器给开发者服务器颁发的身份凭证，开发者可以用session_key请求微信服务器其他接口来获取一些其他信息，所以session_key不应该泄露或者下发到小程序前端。

###### 绑定微信用户身份id和小程序业务用户身份

业务侧用户还没绑定微信侧身份时，会让用户填写业务侧的用户名密码，这两个值会和微信登录凭证一起请求开发者服务器的登录接口，此时开发者后台通过校验用户名密码就拿到了业务侧的用户身份id，通过code到微信服务器获取微信侧的用户身份openid。微信会建议开发者把这两个信息的对应关系存起来，我们把这个对应关系称之为“绑定”。

有了这个绑定信息，小程序在下次需要用户登录的时候就可以不需要输入账号密码，因为通过wx.login()获取到code之后，可以拿到用户的微信身份openid，通过绑定信息就可以查出业务侧的用户身份id，这样静默授权的登录方式显得非常便捷。

###### 业务登录凭证SessionId

微信侧返回的session_key是开发者服务器和微信服务器的会话密钥。同理，开发者服务器和开发者的小程序应该也有会话密钥，也就是SessionId。用户登录成功之后，开发者服务器需要生成会话密钥SessionId，在服务端保持SessionId对应的用户身份信息，同时把SessionId返回给小程序。小程序后续发起的请求中携带上SessionId，开发者服务器就可以通过服务器端的Session信息查询到当前登录用户的身份，这样我们就不需要每次都重新获取code，省去了很多通信消耗。之后还会提到如何利用本地数据缓存的能力把SessionId存储起来，以便在它还没过期的时候能重复利用，以提高通信的性能。

#### 本地数据缓存

本地缓存可用于重新打开小程序时恢复之前的状态，还可用于缓存一些服务端非实时的数据。

###### 读写本地数据缓存

通过wx.getStorage/wx.getStorageSync读缓存，通过wx.setStorage/wx.setStorageSync写数据到缓存，其中Sync后缀的接口表示是同步接口[[1\]](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000a2c7c9f4a981b0086bd31e5b40a#_ftn9)，执行完毕之后会立马返回。

```javascript
//读取操作
wx.getStorage({
  key: 'key1',
  success: function(res) {
    // 异步接口在success回调才能拿到返回值
    var value1 = res.data
  },
  fail: function() {
    console.log('读取key1发生错误')
  }
})

try{
  // 同步接口立即返回值
  var value2 = wx.getStorageSync('key2')
}catch (e) {
  console.log('读取key2发生错误')
}



//写入操作
// 异步接口在success/fail回调才知道写入成功与否
wx.setStorage({
  key:"key",
  data:"value1"
  success: function() {
    console.log('写入value1成功')
  },
  fail: function() {
    console.log('写入value1发生错误')
  }
})

try{
  // 同步接口立即写入
  wx.setStorageSync('key', 'value2')
  console.log('写入value2成功')
}catch (e) {
  console.log('写入value2发生错误')
}
```

其中，key是本地缓存中指定的 key，data是需要存储的内容。

###### 缓存限制和隔离

小程序宿主环境会管理不同小程序的数据缓存，不同小程序的本地缓存空间是分开的，每个小程序的缓存空间上限为10MB，如果当前缓存已经达到10MB，再通过wx.setStorage写入缓存会触发fail回调。

小程序的本地缓存不仅仅通过小程序这个维度来隔离空间，考虑到同一个设备可以登录不同微信用户，宿主环境还对不同用户的缓存进行了隔离，避免用户间的数据隐私泄露。

由于本地缓存是存放在当前设备，用户换设备之后无法从另一个设备读取到当前设备数据。

###### 利用本地缓存提前渲染界面

讨论一个需求：我们要实现了一个购物商城的小程序，首页是展示一堆商品的列表。一般的实现方法就是在页面onLoad回调之后通过wx.request向服务器发起一个请求去拉取首页的商品列表数据，等待wx.request的success回调之后把数据通过setData渲染到界面上：

```javascript
Page({
  onLoad: function() {
    var that = this
    wx.request({
      url: 'https://test.com/getproductlist',
      success: function (res) {
        if (res.statusCode === 200) {
          that.setData({
            list: res.data.list
          })
        }
      }
    })
  }
})
```

设想一下当用户退出小程序再进来，界面仍然会有白屏现象，因为我们需要等待拉取商品列表的请求回来才能渲染商品列表。当然我们还可以再做一些体验上的优化，例如在发请求前，可能我们会在界面上显示一个Loading提示用户在加载中，但是并没有解决这个延迟渲染的现象，这个时候我们可以利用本地缓存来提前渲染界面。

我们在拉取商品列表后把列表存在本地缓存里，在onLoad发起请求前，先检查是否有缓存过列表，如果有的话直接渲染界面，然后等到wx.request的success回调之后再覆盖本地缓存重新渲染新的列表。

```javascript
Page({
  onLoad: function() {
    var that = this
    var list =wx.getStorageSync("list")

    if (list) { // 本地如果有缓存列表，提前渲染
      that.setData({
        list: list
      })
    }
    
    wx.request({
      url: 'https://test.com/getproductlist',
      success: function (res) {
        if (res.statusCode === 200) {
          list = res.data.list
          that.setData({ // 再次渲染列表
            list: list
          })
          wx.setStorageSync("list",list) // 覆盖缓存数据
        }     
           }
    })
  }
})
```

但是你还要留意这个做法的缺点，如果小程序对渲染的数据实时性要求非常高的话，用户看到一个旧数据的界面会非常困惑。因此一般在对数据实时性要求不高的页面采用这个方法来做提前渲染，用以优化小程序体验。

###### 缓存用户登录态SessionId

通常用户在没有主动退出登录前，用户的登录态会一直保持一段时间[[10\]](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000a2c7c9f4a981b0086bd31e5b40a#_ftn10)。如果我们用Javascript的某个变量记录SessionId，当用户重进小程序时，之前内存的SessionId已经丢失，此时我们就需要利用本地缓存的能力来持久化存储SessionId。

```javascript
//page.js 本地缓存持久存储用户登录态SessionId
var app = getApp()

Page({
  onLoad: function() {
    // 调用wx.login获取微信登录凭证
    wx.login({
      success: function(res) {
        // 拿到微信登录凭证之后去自己服务器换取自己的登录凭证 
        wx.request({
          url: 'https://test.com/login',
          data: { code: res.code },
          success: function(res) {
            var data = res.data
            // 把 SessionId 和过期时间放在内存中的全局对象和本地缓存里边
            app.globalData.sessionId =data.sessionId
            wx.setStorageSync('SESSIONID',data.sessionId)         
             // 假设登录态保持1天
            var expiredTime = +new Date() +1*24*60*60*1000
            app.globalData.expiredTime =expiredTime
            wx.setStorageSync('EXPIREDTIME',expiredTime)
          }
        })
      }
    })
  }
})
```

在重新打开小程序的时候，我们把上一次存储的SessionId内容取出来，恢复到内存。

代码清单4-18 利用本地缓存恢复用户登录态SessionId

```javascript
//app.js 利用本地缓存恢复用户登录态SessionId
App({
  onLaunch: function(options) {
    var sessionId =wx.getStorageSync('SESSIONID')
    var expiredTime =wx.getStorageSync('EXPIREDTIME')
    var now = +new Date()
    
    if (now - expiredTime <=1*24*60*60*1000) {
      this.globalData.sessionId = sessionId
      this.globalData.expiredTime = expiredTime
    }
  },
  globalData: {
    sessionId: null,
    expiredTime: 0
  }
})
```

#### 利用微信扫码能力

为了让用户减少输入，我们可以把复杂的信息编码成一个二维码，利用宿主环境wx.scanCode这个API调起微信扫一扫，用户扫码之后，wx.scanCode的success回调会收到这个二维码所对应的字符串信息。

例如餐厅点餐的小程序，我们给餐厅中每个餐桌编号1-100号，把这个数字编码到二维码中[[11\]](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000ce66493c998fb0086c8dbe5100a#_ftn11)，扫码获得编号之后，就可以知道是哪一桌。

```javascript
//page.js
Page({
  // 点击“扫码订餐”的按钮，触发tapScan回调
  tapScan: function() {
    // 调用wx.login获取微信登录凭证
    wx.scanCode({
      success: function(res) {
        var num = res.result // 获取到的num就是餐桌的编号
      }
    })
  }
})
```

#### 获取网络状态

通过小程序提供的获取网络状态的能力，做一些更友好的体验提示。

```javascript
//page.js
Page({
  // 点击“预览文档”的按钮，触发tap回调
  tap: function() {
    wx.getNetworkType({
      success: function(res) {
        // networkType字段的有效值：
        // wifi/2g/3g/4g/unknown(Android下不常见的网络类型)/none(无网络)
        if (res.networkType == 'wifi') {
          // 从网络上下载pdf文档
            wx.downloadFile({
            url:'http://test.com/somefile.pdf',
            success: function (res) {
              // 下载成功之后进行预览文档
              wx.openDocument({
                filePath: res.tempFilePath
              })
            }
          })          
            } else {
          wx.showToast({ title: '当前为非Wifi环境' })
        }
      }
    })
  }
})
```

某些情况下，我们的手机连接到网络的方式会动态变化，例如手机设备连接到一个信号不稳定的Wifi热点，导致手机会经常从Wifi切换到移动数据网络。小程序宿主环境也提供了一个可以动态监听网络状态变化的接口wx.onNetworkStatusChange，让开发者可以及时根据网络状况去调整小程序的体验，wx.onNetworkStatusChange这个接口的使用场景留给读者来思考。

#### 小程序的协同开发

开发者需要真机调试开发版本时，可以点击开发者工具的预览按钮，此时开发者工具会打包当前项目，并上传到微信服务器生成一个二维码，开发者使用当前开发身份的微信扫码就可体验。

###### 小程序基础设计原则

**导航清晰**：导航需要告诉用户，当前在哪，可以去哪，如何回去等问题。开发者应确保各个页面之间层级清晰明确。每个界面的导航，都指向清晰，有路可退。
**流程明确**：应确定当前页面只设置了单一任务，且不出现目标流程之外的内容。此举有利于让用户明确当前操作的目的，从而集中精力聚焦当前任务，并通过简单操作达到结果。
**重点突出**：每个页面都应有明确的重点，以便用户进入一个新页面时都能快速理解页面内容。
**符合预期**：对用户友好的产品，需在设计阶段便将自身信息架构和模型与用户的心理模型匹配，以便于用户能够依据以往的使用经验，降低使用的理解和学习成本，从而快速达成使用目的。
**等待与反馈**：在设计加载等待状态时，应注意以下事项：
若载入等待时间较长，应提供取消操作，并使用进度条显示载入的进度；
载入过程中，应保持动画效果；无动画效果的加载很容易让人产生该界面已经卡死的错觉；
不要在同一个页面同时使用超过1个加载动画。

此外，对于用户的操作结果，小程序也需给出明确的结果反馈，以增强用户的操作信心和控制感。开发者可以根据实际情况，选择不同的反馈样式。例如，对于页面局部的操作，可在操作区域直接反馈。对于页面级别的操作结果，可使用弹出式提示、模态对话框或结果页面展示。
**异常处理**：在设计任务和流程时，可能因为各种原因导致操作失败。在出现异常的时候需要给予用户清晰的状态提示，并告知解决方案，使其有路可退。上文提到的模态对话框和结果页面都可以作为异常状态的提醒方式。此外，在表单项较多的页面中，应明确出错项目，以便用户修改。
**内容和文案准确友好**：使用的语言应简洁，礼貌，易理解。
**和谐统一**：小程序内的设计风格应该是统一、和谐且具有延续性的，这样才能确保用户建立完整的产品品牌认知，更好辨析不同的小程序。
**平台适配**：在小程序的设计过程中，应该充分考虑iOS与Android平台不同的设计规范，对设计进行适当调整以适应不同平台上的用户使用习惯。

###### 用户体验测试和完善体验

关于进行用户体验测试的一些建议：

1. 用户体验测试，可以在设计、开发、测试等全部阶段使用。
2. 尽早进行用户体验测试。
3. 用户测试之前需要确定好需要被检验的流程和任务，需要为用户构建明确的目标，并提示用户以完成任务的方式完成目标。
4. 最好选择产品真实的受众，作为被测试的用户。并在测试时，使用户处于真实场景下。
5. 设计开放性的问题让用户回答。不用带有主观性的询问语言，引导用户回答。
6. 在用户测试过程中，需要全程做好记录。

## 发布

小程序提供了两种发布模式：全量发布和分阶段发布。全量发布是指当点击发布之后，所有用户访问小程序时都会使用当前最新的发布版本。分阶段发布是指分不同时间段来控制部分用户使用最新的发布版本，分阶段发布我们也称为灰度发布。一般来说，普通小程序发布时采用全量发布即可，当小程序承载的功能越来越多，使用的用户数越来越多时，采用分阶段发布是一个非常好的控制风险的办法。因为随着程序的复杂度提高以及影响面的扩大，新版本的代码改动或多或少会带来Bug，作为服务方当然不希望异常的服务状态一下子扩散到整个用户群体，此时应该通过分阶段发布来**逐步观察服务的稳定性**，**再决定是否进行全量发布**。

还需要留意一点，并非全量发布之后，用户就会立即使用到最新版的小程序，这是因为微信客户端存有旧版本小程序包缓存。用户在使用小程序时会优先打开本地的小程序包，微信客户端在某些特定的时机异步去更新最新的小程序包。一般我们认为全量发布的24小时后，所有用户才会真正使用到最新版的小程序。

###### 小程序码

很多场景下用户会通过扫码快速进入一个小程序，在小程序设计的初期，用户在扫一个二维码时，二维码的背后有可能是公众号、小程序、网页服务、支付页面、添加好友等不同的服务。为了让用户在扫码之前就有一个明确的预期，因此微信设计了小程序码。

相对于二维码来说，小程序码在样式上更具辨识度和视觉冲击力，可以帮助开发者更好地推广小程序。在发布小程序之后，小程序管理平台会提供对应的小程序码的预览和下载。

## 运营

发布完小程序之后，我们还需要关注小程序的运行数据，帮助小程序产品迭代优化和运营。开发者可以利用小程序平台里面向产品的运营数据分析和面向开发的运维中心来完成数据运营的工作。

###### 常规分析

开发网页和App应用都需要开发者自己编写代码来上报访问数据，小程序平台则直接内置在宿主环境底层，无需开发者新增一行代码。

小程序数据分析，是面向小程序开发者、运营者的数据分析工具，提供关键指标统计、实时访问监控、自定义分析等，帮助小程序产品迭代优化和运营。开发者可以登录小程序管理平台，通过左侧“数据分析”菜单可以进入数据分析查看。

我们在小程序平台还可以查看小程序的访问分析，包括小程序用户访问规模、来源、频次、时长、深度、留存以及页面详情等数据，可以用于具体分析用户新增、活跃和留存情况。为了让开发者可以更加详细了解使用的用户情况，数据分析也提供了小程序的用户画像数据，包括用户年龄、性别、地区、终端及机型分布。

###### 自定义分析

除了小程序宿主环境提供的数据分析能力，为了让开发者可以更加灵活多维和近实时的用户行为分析，小程序平台提供了自定义上报的特性，开发者可以对用户在小程序内的行为做精细化跟踪，满足页面访问等标准统计以外的个性化分析需求。在小程序官方提供的小程序自定义分析文档[[6\]](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000282c19bc1a88b0086ad44e5b80a#_ftn6)有非常详细的指引，这里不再赘述。。

###### 运维中心

小程序宿主环境已经内置了异常检测的模块，并且上报到小程序平台，开发者可以通过小程序平台的“运维中心”查看具体的错误日志，开发者根据日志详细定位自己代码的异常处并及时修复。通过开发者自己主动去查阅日志定位错误的方式会显得比较被动，因为开发者不可能时时刻刻都在电脑前关注这个日志的变化曲线，因此比较推荐的方法是通过运维中心的监控告警功能，开发者设置合理的错误阈值，再通过加入微信告警群，当小程序运行发生大量异常现象时，微信告警群会提醒开发者，此时开发者再登录小程序管理平台查阅错误日志。小程序平台目前只提供了脚本错误告警，如果需要监控异常的访问或者服务接口耗时时，需要开发者自行开发监控系统，并在小程序逻辑代码加上对应的数据上报。

#### 底层框架：

###### 技术选型

我们在对小程序的架构设计时的要求只有一个，就是要快，包括要渲染快、加载快等。当用户点开某个小程序时，我们期望体验到只有很短暂的加载界面，在一个过渡动画之后可以马上看到小程序的主界面。

一般来说，渲染界面的技术有三种：用纯客户端原生技术来渲染，用纯 Web 技术来渲染，用介于客户端原生技术与 Web 技术之间的，互相结合各自特点的技术（**下面统称 Hybrid 技术**）来渲染。

由于小程序的宿主是微信，所以我们不太可能用纯客户端原生技术来编写小程序 。如果这么做，那小程序代码需要与微信代码一起编包，跟随微信发版本，这种方式跟开发节奏必然都是不对的。因此，我们需要像Web 技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。

但如果用纯 Web 技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些性能问题，这是因为在 Web 技术中，UI渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。

按照上面的讨论，使用纯客户端原生技术或纯 Web 技术都有各自的缺点，那如果使用两者结合起来的 Hybrid 技术来渲染小程序，能否优于各自独立渲染的技术方案呢？实际上，这种 Hybrid 技术在业界过去几年里演化过数种技术方案，典型的如早期的PhoneGap[[1\]](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=0006a2289c8bb0bb0086ee8c056c0a#_ftn1)，还有近两年流行的React Native[[2\]](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=0006a2289c8bb0bb0086ee8c056c0a#_ftn2)（下称 RN），还有像微信网页里的 JS-SDK[[3\]](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=0006a2289c8bb0bb0086ee8c056c0a#_ftn3) 这种轻量级的应用。

从渲染底层来看，PhoneGap与微信 JS-SDK 是类似的，它们最终都还是使用浏览器内核来渲染界面。而 RN 则不同，虽然是用 Web 相关技术来编写，同样是利用了 JavaScript 解释执行的特性，但 RN 在渲染底层是用客户端原生渲染的。实际上，小程序最初选型时 RN 是候选之一，虽然说 RN 是结合了 React 框架的代码组成方式，但是我们完全可以剥离React 框架这套写法，定义出更符合小程序特点的代码组成方式。不过，最终我们并没有选择这种类 RN 技术，原因有三：

1. RN 所支持的样式是 CSS 的子集，会满足不了 Web 开发者日渐增长的需求，而对 RN 的改造具有不小的成本和风险。
2. RN 现有能力下还存在的一些不稳定问题，比如性能、Bug等。RN 是把渲染工作全都交由客户端原生渲染，实际上一些简单的界面元素使用 Web 技术渲染完全能胜任，并且非常稳定。
3. RN 存在一些不可预期的因素，比如近期就出现了许可协议问题。

最终，我们选择类似于微信 JSSDK 这样的 Hybrid 技术，即界面主要由成熟的 Web 技术渲染，辅之以大量的接口提供丰富的客户端原生能力。同时，每个小程序页面都是用不同的WebView去渲染，这样可以提供更好的交互体验，更贴近原生体验，也避免了单个WebView的任务过于繁重。

###### 双线程的由来：

为了解决管控与安全问题，必须提供一个沙箱环境来运行开发者的JavaScript 代码。这个沙箱环境不能有任何浏览器相关接口，只提供纯JavaScript 的解释执行环境。

考虑到小程序是一个多 WebView 的架构，每一个小程序页面都是不同的WebView 渲染后显示的，在这个架构下我们不好去用某个WebView中的ServiceWorker去管理所有的小程序页面。

得益于客户端系统有JavaScript 的解释引擎（在iOS下是用内置的 JavaScriptCore框架，在安卓则是用腾讯x5内核提供的JsCore环境），我们可以创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码，也就是我们前面一直提到的逻辑层。而界面渲染相关的任务全都在WebView线程里执行，通过逻辑层代码去控制渲染哪些界面，那么这一层当然就是所谓的渲染层。这就是小程序双线程模型的由来。

###### 天生的延时

既然小程序是基于双线程模型，那就意味着任何数据传递都是线程间的通信，也就是都会有一定的延时。这不像传统Web那样，当界面需要更新时，通过调用更新接口UI就会同步地渲染出来。在小程序架构里，这一切都会变成异步。

逻辑层与渲染层需要有一定的机制保证时序正确，这些工作在小程序框架里会处理好，开发者只需要理解生命周期，以及控制合适的时机更新UI即可。

除了逻辑层与渲染层之间的通信有延时，各层与客户端原生交互同样是有延时的。以逻辑层为例，开发者的代码是跑在逻辑层这个线程之上，而客户端原生是跑在微信主线程（安卓上是线程）之上，所以注册给逻辑层有关客户端能力的接口，实际上也是跟微信主线程之间的通信，同样意味着有延时。这也是我们看到大部分提供的接口都是异步的原因。

###### 组件系统

Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。

**内置组件**：我们基于Exparser框架，内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。

**自定义组件**：自定义组件是开发者可以自行扩充的组件。开发者可以将常用的节点树结构提取成自定义组件，实现代码复用。

###### 组件间通信

不同组件实例间的通信有WXML属性值传递、事件系统、selectComponent和relations等方式。其中，WXML属性值传递是从父组件向子组件的基本通信方式，而事件系统是从子组件向父组件的基本通信方式。

在通常的理解中，事件可以分为冒泡事件和非冒泡事件，但在ShadowDOM体系中，冒泡事件还可以划分为在Shadow Tree上冒泡的事件和在Composed Tree上冒泡的事件。如果在Shadow Tree上冒泡，则冒泡只会经过这个组件Shadow Tree上的节点，这样可以有效控制事件冒泡经过的范围。

```html
<!-- input-with-label的WXML -->
<label>
  <input />
  <slot />
</label>
```

```html
<!-- 页面的WXML -->
<view>
  <input-with-label>
    <button />
  </input-with-label>
</view>
```

用上面的例子来说，当在 button 上触发一个事件时：
如果事件是非冒泡的，那只能在 button 上监听到事件；
如果事件是在 Shadow Tree 上冒泡的，那 button 、 input-with-label 、view 可以依次监听到事件；
如果事件是在 Composed Tree 上冒泡的，那 button 、 slot 、label 、 input-with-label 、 view 可以依次监听到事件。

在自定义组件中使用triggerEvent触发事件时，可以指定事件的bubbles、composed和capturePhase属性，用于标注事件的冒泡性质。

```javascript
Component({
  methods: {
    helloEvent: function() {
      this.triggerEvent('hello', {}, {
        bubbles: true,      // 这是一个冒泡事件
        composed: true,     // 这个事件在Composed Tree 上冒泡
        capturePhase: false // 这个事件没有捕获阶段
      })
    }
  }
})
```

小程序基础库自身也会通过这套事件系统提供一些用户事件，如tap、touchstart和form组件的submit等。其中，tap等用户触摸引发的事件是在ComposedTree上的冒泡事件，其他事件大多是非冒泡事件。

###### 原生组件

由客户端原生参与组件的渲染，这类组件我们称为“原生组件”。原生组件在WebView这一层的渲染任务是很简单，只需要渲染一个占位元素，之后客户端在这块占位元素之上叠了一层原生界面。因此，原生组件的层级会比所有在WebView层渲染的普通组件要高。
常用的几个原生组件：

| **组件名** | **名称**     | **是否有\****context** | **描述**                         |
| :--------- | :----------- | :--------------------- | :------------------------------- |
| video      | 视频         | 是                     | 播放视频                         |
| map        | 地图         | 是                     | 展示地图                         |
| canvas     | 画布         | 是                     | 提供一个可以自由绘图的区域       |
| picker     | 弹出式选择器 | 否                     | 初始时没有界面，点击时弹出选择器 |

交互比较复杂的原生组件都会提供“context”，用于直接操作组件。canvas组件context对象示例：

```html
<!-- WXML -->
<canvas canvas-id="myCanvas"></canvas>

//js
const ctx = wx.createCanvasContext('myCanvas')
ctx.setFillStyle('red')
ctx.fillRect(10, 10, 150, 75)
ctx.draw()
```

这段代码可以创建WXML中对应canvas节点的context，通过调用context中的方法，在画布上绘制一个矩形。类似于canvas，video、map等原生组件都可以创建context，context中提供的方法详见文档。

######  原生组件渲染限制

原生组件脱离在WebView渲染流程外，这带来了一些限制。最主要的限制是一些CSS样式无法应用于原生组件，例如，不能在父级节点使用overflow:hidden来裁剪原生组件的显示区域；不能使用transformrotate让原生组件产生旋转等。

开发者最为常见的问题是，原生组件会浮于页面其他组件之上（相当于拥有正无穷大的z-index值）使其它组件不能覆盖在原生组件上展示。想要解决这个问题，可以考虑使用cover-view和cover-image组件。这两个组件也是原生组件，同样是脱离WebView的渲染流程外，而原生组件之间的层级就可以按照一定的规则控制。

**tip**:ReactNative 是一个 JavaScript 框架，用来编写原生的 iOS 和 Android 应用。

#### 性能优化：

###### 启动

在小程序启动时，微信会为小程序展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。

<img src="/Users/max/GithubRepositories/iOS-Develpoment/img/miniProgram/小程序启动.png" style="zoom:50%;" />

下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包。代码包大小可以在开发者工具的“详情”栏中找到。以下是一些常规的控制代码包大小的方法。
1，精简代码，去掉不必要的WXML结构和未使用的WXSS定义。
2，减少在代码包中直接嵌入的资源文件。
3，压缩图片，使用适当的图片格式。
如果小程序比较复杂，优化后的代码总量可能仍然比较大，此时可采用分包加载的方式进行优化。

###### 分包加载流程

采用分包时，小程序的代码包可以被划分为几个：一个是“主包”，包含小程序启动时会马上打开的页面代码和相关资源；其余是“分包”，包含其余的代码和资源。这样，小程序启动时，只需要先将主包下载完成。分包目录和相应的app.json示例如下：
![](/Users/max/GithubRepositories/iOS-Develpoment/img/miniProgram/分包目录.png)

```json
{
  "pages":[
    "pages/index",
    "pages/logs"
  ],
  "subPackages": [
    {
      "root": "packageA",
      "pages": [
        "pages/cat",
        "pages/dog"
      ]
    }, {
      "root": "packageB",
      "pages": [
        "pages/apple",
        "pages/banana"
      ]
    }
  ]
}
```

一个支持分包的小程序目录结构可以组织成上图的形式。代码根目录下有“packageA”和“packageB”两个子目录（它们的名字需要在app.json中声明），这两个子目录就构成了两个分包，每个分包下都可以有自己的页面代码和资源文件。而除掉这两个目录的部分就是小程序的主包。在小程序启动时，“packageA”和“packageB”两个子目录的内容不会马上被下载下来，只有主包的内容才会被下载。
使用分包时需要注意代码和资源文件目录的划分。启动时需要访问的页面及其依赖的资源文件应放在主包中。

###### 代码包加载

代码包下载（或从缓存中读取）完成后，小程序的代码会被加载到适当的线程中执行。此时，所有app.js、页面所在的JS文件和所有其他被require的JS文件会被自动执行一次，小程序基础库会完成所有页面的注册。在小程序代码调用Page构造器的时候，小程序基础库会记录页面的基础信息，如初始数据（data）、方法等。需要注意的是，如果一个页面被多次创建，并不会使得这个页面所在的JS文件被执行多次，而仅仅是根据初始数据多生成了一个页面实例（this），在页面JS文件中直接定义的变量，在所有这个页面的实例间是共享的。

###### 页面层级准备

在视图层内，小程序的每一个页面都独立运行在一个页面层级上。小程序启动时仅有一个页面层级，每次调用wx.navigateTo，都会创建一个新的页面层级；相对地，wx.navigateBack会销毁一个页面层级。

页面层级的准备工作分为三个阶段。第一阶段是启动一个WebView。第二阶段是在WebView中初始化基础库，此时还会进行一些基础库内部优化，以提升页面渲染性能。第三阶段是注入小程序WXML结构和WXSS样式，使小程序能在接收到页面初始数据之后马上开始渲染页面（这一阶段无法在小程序启动前执行）。

对于wx.redirectTo，这个调用不会打开一个新的页面层级，而是将当前页面层级重新初始化：重新传入页面的初始数据、路径等，视图层清空当前页面层级的渲染结果然后重新渲染页面。

#### 数据通信

在每个小程序页面的生命周期中，存在着若干次页面数据通信。逻辑层向视图层发送页面数据（data和setData的内容），视图层向逻辑层反馈用户事件。

###### 页面初始数据通信

在小程序启动或一个新的页面被打开时，页面的初始数据（data）和路径等相关信息会从逻辑层发送给视图层，用于视图层的初始渲染。Native层会将这些数据直接传递给视图层，同时向用户展示一个新的页面层级，视图层在这个页面层级上进行界面绘制。视图层接收到相关数据后，根据页面路径来选择合适的WXML结构，WXML结构与初始数据相结合，得到页面的第一次渲染结果。

###### 更新数据通信

初始渲染完毕后，视图层可以在开发者调用setData后执行界面更新。在数据传输时，逻辑层会执行一次JSON.stringify来去除掉setData数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将setData所设置的数据字段与data合并，使开发者可以用this.data读取到变更后的数据。
因此，为了提升数据更新的性能，开发者在执行setData调用时，最好遵循以下原则：
1.不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用；
2.数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据；
3.与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下。

```javascript
Page({
  onShow: function() {
    // 不要频繁调用setData
    this.setData({ a: 1 })
    this.setData({ b: 2 })
    // 绝大多数时候可优化为
    this.setData({ a: 1, b: 2 })
    // 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在data外
    this.setData({
      myData: {
        a: '这个字符串在WXML中用到了',
        b: '这个字符串未在WXML中用到，而且它很长…………………………'
      }
    })
    
      // 可以优化为
    this.setData({
      'myData.a': '这个字符串在WXML中用到了'
    })
    this._myData = {
      b: '这个字符串未在WXML中用到，而且它很长…………………………'
    }

  }
})
```

###### 用户事件通信

视图层会接受用户事件，如点击事件、触摸事件等。用户事件的通信比较简单：当一个用户事件被触发且有相关的事件监听器需要被触发时，视图层会将信息反馈给逻辑层。视图层中有一套高效的事件处理体系，可以快速完成事件生成、冒泡、捕获等过程。
视图层将事件反馈给逻辑层时，同样需要一个通信过程。这个通信过程是异步的，会产生一定的延迟，延迟时间同样与数据量正相关。降低延迟时间的方法主要有两个。
1.去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数；
2.事件绑定时需要传输target和currentTarget的dataset，因而不要在节点的data前缀属性中放置过大的数据。

###### 视图层渲染

视图层在接收到初始数据（data）和更新数据（setData数据）时，需要进行视图层渲染。减少WXML的节点数量可以有效降低初始渲染和重渲染的时间开销。

```html
<view data-my-data="{{myData}}"> <!-- 这个 view 和下一行的 view 可以合并 -->
  <view class="my-class" data-my-data="{{myData}}" bindtap="onTap">
    <text> <!-- 这个 text 通常是没必要的 -->
      {{myText}}
    </text>
  </view>
</view>

<!-- 可以简化为 -->

<view class="my-class" data-my-data="{{myData}}" bindtap="onTap">
  {{myText}}
</view>
```

在进行当前节点树与新节点树的比较时，会着重比较setData数据影响到的节点属性。因而，去掉不必要设置的数据、减少setData的数据量也有助于提升这一个步骤的性能。

###### 原生组件通信

一些原生组件支持使用context来更新组件。不同于setData，使用context来更新组件并不会涉及到重渲染过程，数据通信过程也不同。在setData的数据通信流程中，数据从逻辑层经过native层转发，传入视图层的WebView，再经过一系列渲染步骤之后传入组件。而使用context时，数据从逻辑层传到native层后，直接传入组件中，这样可以显著降低传输延迟。

###### 小程序基础库

小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。这样做的好处有两点：降低业务小程序的代码包大小，可以单独修复基础库中的Bug，无需修改业务小程序代码。 

###### 基础库的版本号

小程序基础库版本号使用 semver 规范，格式为 Major.Minor.Patch，其中Major、Minor、Patch均为整数，1.9.901、2.44.322、10.32.44 都是符合 semver 风格的版本号。通常月度发布版会把Minor提升一位，例如从1.9.x升级到1.10.x，修正版会把Patch提升一位，例如1.10.0升级到 1.10.1。Major则是重大特性发布时才会提升一位。
在小程序中，可以通过wx.getSystemInfo()或者wx.getSystemInfoSync()方法获取基础库版本号：

```javascript
var info = wx.getSystemInfoSync()
console.log("小程序基础库版本号为：" + info.SDKVersion)
```

###### 异常

JavaScript语言是一种非常灵活的脚本语言，由于没有静态编译的过程，在运行时就更容易出现异常。

###### 代码编译

代码编译过程包括本地预处理、本地编译和服务器编译。为了快速预览，微信开发者工具模拟器运行的代码只经过本地预处理、本地编译，没有服务器编译过程，而微信客户端运行的代码是额外经过服务器编译的。

###### 模拟器

小程序模拟器模拟小程序在微信客户端的逻辑和界面表现，方便开发者实时查看代码效果。由于系统差异以及微信客户端特有的一些交互流程，少部分的API无法在模拟器上进行模拟，但绝大部分 API 均能够在模拟器上呈现出正确的状态。同时微信开发者工具提供多种机型，方便开发者进行UI适配。

**更多总结请看官方文档和社区，在实践中沉淀…**



#### 蓝盾流程：

[从零开始搭建微信小程序研发流程 by 蓝盾](http://km.oa.com/articles/show/431102?kmref=search&from_page=1&no=5)













